engine.execute_client_cmd("clear")
engine.execute_client_cmd("showconsole")

ffi.cdef[[
    struct c_color { unsigned char clr[4]; };
    struct vec3_t { float x, y, z; };
    typedef void(__thiscall* add_box_overlay_t)(void*, const struct vec3_t&, const struct vec3_t&, const struct vec3_t&, struct vec3_t const&, int, int, int, int, float);

    void* CreateFileA(const char* lpFileName, unsigned long dwDesiredAccess, unsigned long dwShareMode, unsigned long lpSecurityAttributes, unsigned long dwCreationDisposition, unsigned long dwFlagsAndAttributes, void* hTemplateFile);
    bool ReadFile(void* hFile, char* lpBuffer, unsigned long nNumberOfBytesToRead, unsigned long* lpNumberOfBytesRead, int lpOverlapped);
    bool WriteFile(void* hFile, char* lpBuffer, unsigned long nNumberOfBytesToWrite, unsigned long* lpNumberOfBytesWritten, void* lpOverlapped);
    unsigned long GetFileSize(void* hFile, unsigned long* lpFileSizeHigh);
    bool CreateDirectoryA(const char* lpPathName, void* lpSecurityAttributes);
    void* CloseHandle(void *hFile);

    typedef struct _OVERLAPPED {
        unsigned long* Internal;
        unsigned long* InternalHigh;
        union {
            struct {
                unsigned long Offset;
                unsigned long OffsetHigh;
            } DUMMYSTRUCTNAME;
            void* Pointer;
        } DUMMYUNIONNAME;
        void*    hEvent;
    } OVERLAPPED, *LPOVERLAPPED;
]]

    client.color_print = function(color, text)
        console_color = ffi.new("struct c_color")
        engine_cvar = ffi.cast("void***", se.create_interface("vstdlib.dll", "VEngineCvar007"))
        console_print = ffi.cast("void(__cdecl*)(void*, const struct c_color&, const char*, ...)", engine_cvar[0][25])
    
        console_color.clr[0] = color.red * 255
        console_color.clr[1] = color.green * 255
        console_color.clr[2] = color.blue * 255
        console_color.clr[3] = color.alpha * 255
        console_print(engine_cvar, console_color, text)
    end
    
    client.multi_cprint = function(...)
        local args = {...}
        local length = #args
      
        if length % 2 ~= 0 then error("multicprint criticals odds", 2) end
    
        length = length /2
        for index = 1, length do
            local text = args[index]
            local color = args[length + index]
        
            local type_of_text = type(text)
            if type_of_text ~= 'string' then error("nowhere finded string data", 2) end
    
            client.color_print(color, text)
        end
    end
    
    local colors = {
        gray = color_t.new(220, 220, 220, 255),
        dark_blue = color_t.new(99, 150, 255, 180),
        yellow = color_t.new(255, 236, 0, 235),
        red_yellow = color_t.new(255, 158, 5, 235),
        orange = color_t.new(250, 214, 165,255),
        white = color_t.new(255,255,255,255),
        helio_color = color_t.new(160,148,255,255)
}

    
    console_welcome_msg = function()
        client.multi_cprint(
    "██╗  ██╗███████╗██╗     ██╗ ██████╗\n",
    "██║  ██║██╔════╝██║     ██║██╔═══██╗\n",
    "███████║█████╗  ██║     ██║██║   ██║\n",
    "██╔══██║██╔══╝  ██║     ██║██║   ██║\n",
    "██║  ██║███████╗███████╗██║╚██████╔╝\n",
    "╚═╝  ╚═╝╚══════╝╚══════╝╚═╝ ╚═════╝ [DEBUG]\n\n",
            "welcome back to ", "helio.yaw\n",
            "version: ", "2.0\n",
            "name: ", client.get_username().."\n",
    
            colors.helio_color,
            colors.helio_color,
            colors.helio_color,
            colors.helio_color,
            colors.helio_color,
            colors.helio_color,
            colors.white,
            colors.helio_color,
            colors.white,
            colors.helio_color,
            colors.white,
            colors.helio_color
        )
    end
    console_welcome_msg()

    tab = ui.add_combo_box("helio.yaw / tab", "", {"Ragebot", "Anti Aim", "Visuals", "Misc", "Colors"}, 0)
    pinge = ui.add_check_box("Ping Spike", "pinge", false)
    ping_enable = ui.add_key_bind("Keybind", "ping_enable", 0, 1)
    pin_value = ui.add_slider_int("Ping", "pin_value", 0, 200, 100)
    jumpscout = ui.add_check_box("Jump Scout", "jumpscout", false)
    jump_hc = ui.add_slider_int("Hitchance in air", "ryukox_jumphc", 0, 100, 40)
    baim_on_dmg = ui.add_check_box("Body on Min Dmg", "baim_on_dmg", false)
    lethal_system = ui.add_multi_combo_box("Lethal System", "lethal_system", {"Force Body", "Force Safepoints"}, {false, false})
    exploit = ui.add_multi_combo_box("Exploits", "exploit", {"Fake Flick", "Pitch up on air"}, {false, false})
    fake_flick_switch_key = ui.add_key_bind("Side Switch", "fake_flick_switch_key", 0, 3)
    
    antibrute = ui.add_check_box("Anti Bruteforce", "antibrute", false)
    antihit_antiaim_manuals = ui.add_check_box("Manual Yaw", "manuals", false)
    antihit_antiaim_left = ui.add_key_bind("Manual Left", "antihit_antiaim_left", 0, 3)
    antihit_antiaim_right = ui.add_key_bind("Manual Right", "antihit_antiaim_right", 0, 3)
    aa_builder = ui.add_check_box("Anti Aim Builder", "aa_builder", false)
    


    windows_ui = ui.add_multi_combo_box("UI", "windows_ui", {"Watermark", "Keybinds", "Indicators", "Arrows", "State panel"}, {false, false, false, false, false})
    styles = ui.add_combo_box("Indicators Type", "styles", {"Short", "Long"}, 0)
    souls = ui.add_combo_box("Style", "souls", {"Solus v1", "Solus v2"}, 0)
    color_back = ui.add_color_edit("Color background", "color_back", true, color_t.new(0, 0, 0, 150))
    col = ui.add_color_edit("Color", "col1", true, color_t.new(119, 130, 240, 255))
    colar = ui.add_color_edit("Color arrows", "col2", true, color_t.new(255, 255, 255, 255))
    thirdperson_enable = ui.add_check_box("Thirdperson Distance", "thirdperson_enable", false)
    distation = ui.add_slider_int("Value", "distation", 30, 200, 100)
    is_enabled = ui.add_check_box('Hitmarker', 'vis_shotmarkers_enable', false)
    text_hit_miss = ui.add_multi_combo_box("Text", "text_hit_miss", {"On Hit", "On Miss"}, {false, false})
    col_hit = ui.add_color_edit("Color hit", "col_hit", true, color_t.new(255, 255, 255, 255))
    col_miss = ui.add_color_edit("Color miss", "col_miss", true, color_t.new(255, 122, 122, 255))
    enable_scope = ui.add_check_box("Custom Scope", "enable_scope", false)
    line_color_first = ui.add_color_edit("Color first", "line_color_first", true, color_t.new(255, 255, 255, 255))
    line_color_second = ui.add_color_edit("Color second", "line_color_second", true, color_t.new(255, 255, 255, 0))
    line_offset = ui.add_slider_int("Offset", "line_offset", 0, 500, 10)
    line_length = ui.add_slider_int("Length", "line_length", 0, 1000, 100)
    viewmodel_on_scope = ui.add_check_box("Scope Viewmodel", "viewmodel_on_scope", false)
    log_enable = ui.add_check_box("Logs", "log_enable", false)
    
    autostraf = ui.add_check_box("Autostrafer fix", "autostraf", false)
    trashtalk_enabled = ui.add_check_box("Trash talk", "trashtalk_enabled", false)
    clan = ui.add_check_box("Clantag", "clan", false)
    buybot_enable = ui.add_check_box("Buybot", "buybot_enable", false)
    primary_weapon = ui.add_combo_box("Primary", "primary_weapon", {"None", "SCAR20 / G3SG1", "AWP", "Scout", "AK-47 / M4A4 / M4A1-S", "AUG / SG553", "Famas / Galil AR"}, 0)
    secondary_weapon = ui.add_combo_box("Secondary", "secondary_weapon", {"None", "Dual Berretas", "Deagle / Revolver", "Five seven / Tec-9 / CZ75-Auto", "P250"}, 0)
    utilites = ui.add_multi_combo_box("Utilites", "utilites", { "Armor", "HE Grenade", "Molotov", "Smoke", "Taser", "Defuser" }, { false, false, false, false, false, false })
    

local function tabsystem ()
    rage = tab:get_value() == 0;
    aa = tab:get_value() == 1;
    vis = tab:get_value() == 2;
    misc = tab:get_value() == 3;
    colors = tab:get_value() == 4;

    pin = pinge:get_value()
    colhitactive = is_enabled:get_value()
    distantactive = thirdperson_enable:get_value()
    scopeactive = enable_scope:get_value()
    byubotactive = buybot_enable:get_value()
    pingactive = ping_enable:is_active()
    hitchance_active = jumpscout:get_value()
    solus_active = windows_ui:get_value(0)
    solus_active_keybind = windows_ui:get_value(1)
    theme_active = windows_ui:get_value(2)
    solus_active_state = windows_ui:get_value(4)

    mans = antihit_antiaim_manuals:get_value()
    aa_active = aa_builder:get_value()
    switch_side = exploit:get_value(0)
    
--rage
    pinge:set_visible(rage)
    ping_enable:set_visible(rage and pin)
    pin_value:set_visible(rage and pin)
    jumpscout:set_visible(rage)
    jump_hc:set_visible(rage and hitchance_active)
    baim_on_dmg:set_visible(rage)
    lethal_system:set_visible(rage)
    exploit:set_visible(rage)
    fake_flick_switch_key:set_visible(rage and switch_side)
--aa
    aa_builder:set_visible(aa)
    

    antihit_antiaim_manuals:set_visible(aa)
    antibrute:set_visible(aa)
    antihit_antiaim_left:set_visible(aa and mans)
    antihit_antiaim_right:set_visible(aa and mans)
--visual
    windows_ui:set_visible(vis)
    styles:set_visible(vis and theme_active)
    souls:set_visible(vis and solus_active or solus_active_state and vis or solus_active_keybind and vis)
    thirdperson_enable:set_visible(vis)
    distation:set_visible(vis and distantactive)
    is_enabled:set_visible(vis)
    text_hit_miss:set_visible(vis and colhitactive)
    enable_scope:set_visible(vis)
    line_offset:set_visible(vis and scopeactive)
    line_length:set_visible(vis and scopeactive)
    viewmodel_on_scope:set_visible(vis)
    log_enable:set_visible(vis)
--misc
    autostraf:set_visible(misc)
    trashtalk_enabled:set_visible(misc)
    clan:set_visible(misc)
    buybot_enable:set_visible(misc)
    primary_weapon:set_visible(misc and byubotactive)
    secondary_weapon:set_visible(misc and byubotactive)
    utilites:set_visible(misc and byubotactive)
--color
    col:set_visible(colors)
    colar:set_visible(colors)
    col_hit:set_visible(colors and colhitactive)
    col_miss:set_visible(colors and colhitactive)
    line_color_first:set_visible(colors and scopeactive)
    line_color_second:set_visible(colors and scopeactive)
    color_back:set_visible(colors)
end
    client.register_callback("paint", tabsystem)


local ffi = require("ffi")
 
ffi.cdef[[
    bool CreateDirectoryA(const char* lpPathName, void* lpSecurityAttributes);
    void* __stdcall URLDownloadToFileA(void* LPUNKNOWN, const char* LPCSTR, const char* LPCSTR2, int a, int LPBINDSTATUSCALLBACK);      
    void* __stdcall ShellExecuteA(void* hwnd, const char* op, const char* file, const char* params, const char* dir, int show_cmd);

    bool DeleteUrlCacheEntryA(const char* lpszUrlName);
]]
local urlmon = ffi.load 'UrlMon'
local wininet = ffi.load 'WinInet'
local gdi = ffi.load 'Gdi32'

Download = function(from, to)
    wininet.DeleteUrlCacheEntryA(from)
    urlmon.URLDownloadToFileA(nil, from, to, 0,0)
end

CreateDir = function(path)
    ffi.C.CreateDirectoryA(path, NULL)
end


CreateDir("C:\\helio\\")
CreateDir("lua")
CreateDir("lua\\nix")

Download(decode('aHR0cHM6Ly9jZG4uZGlzY29yZGFwcC5jb20vYXR0YWNobWVudHMvMTA1NzU3NDQzNDg3NTEyMTcyNC8xMDYyNDM1ODk5MTI5OTk5NDMwL0Fycm93cy50dGY'), 'C:\\helio\\Arrows.ttf')
Download(decode('aHR0cHM6Ly9jZG4uZGlzY29yZGFwcC5jb20vYXR0YWNobWVudHMvMTA1NzU3NDQzNDg3NTEyMTcyNC8xMDcyOTMyMTYzNTQyMDc3NDcwL3VuZGVmZWF0ZWQudHRm'), 'C:\\helio\\undefeated.ttf')
Download(decode('aHR0cHM6Ly9jZG4uZGlzY29yZGFwcC5jb20vYXR0YWNobWVudHMvMTA1NzU3NDQzNDg3NTEyMTcyNC8xMDYxNTUyMzI4NDYyODM1NzYyL3NtYWxsZXN0cGl4ZWwudHRm'), 'C:\\helio\\smallestpixel.ttf')

Download(decode('aHR0cHM6Ly9jZG4uZGlzY29yZGFwcC5jb20vYXR0YWNobWVudHMvMTA1NzU3NDQzNDg3NTEyMTcyNC8xMDY3Mzg2NjkzMzEwNzYzMDI4L2Rpc2NvcmQubHVh'), 'lua\\nix\\discord.lua')
Download(decode('aHR0cHM6Ly9jZG4uZGlzY29yZGFwcC5jb20vYXR0YWNobWVudHMvMTA1NzU3NDQzNDg3NTEyMTcyNC8xMDY3Mzg2NjkzODE0MDY3MjUwL2h0dHAubHVh'), 'lua\\nix\\http.lua')
Download(decode('aHR0cHM6Ly9jZG4uZGlzY29yZGFwcC5jb20vYXR0YWNobWVudHMvMTA1NzU3NDQzNDg3NTEyMTcyNC8xMDY3Mzg2Njk0MTk5OTUxMzYwL2pzb24ubHVh'), 'lua\\nix\\json.lua')


local username = string.lower(client.get_username())
local user_split = string.gsub(username,"%s+", "") 

local ffi = require("ffi")
ffi.cdef[[
    int __stdcall GetVolumeInformationA(
    const char* lpRootPathName,
    char* lpVolumeNameBuffer,
    uint32_t nVolumeNameSize,
    uint32_t* lpVolumeSerialNumber,
    uint32_t* lpMaximumComponentLength,
    uint32_t* lpFileSystemFlags,
    char* lpFileSystemNameBuffer,
    uint32_t nFileSystemNameSize
    );
]]

function getSerialNumber()
    local serial = ffi.new("unsigned long[1]", 0)
    ffi.C.GetVolumeInformationA(nil, nil, 0, serial, nil, nil, nil, 0)
    return serial[0]
end

local processor = encode(string.lower(string.gsub(os.getenv('PROCESSOR_IDENTIFIER'),"%s+", "")) ..getSerialNumber()) ..'=='

local Discord = require 'nix/discord'
local Webhook, RichEmbed = Discord.Webhook, Discord.RichEmbed

local webhook = Webhook.new('https://discord.com/api/webhooks/1068962221717213315/dONMkLxejxUik_9pRH2yIz31Ch3olhc1vmtDc6gaobDkLTIMmzztTshr09gY7TdDUOOW')

local embed = RichEmbed.new({
    title = 'Lua loaded',
    description = string.format('**User**: %s \n**Time**: %s \n**PC Name**: %s \n**HWID**: %s', client.get_username(), os.date("%H:%M"), os.getenv("USERNAME"), processor),
    color = 0x0000000F
})

webhook:setUsername('Lua logger')

webhook:send(embed)


client.register_callback("paint", function()
    se.get_convar("r_3dsky"):set_int(0)
    se.get_convar("r_shadows"):set_int(0)
    se.get_convar("cl_csm_static_prop_shadows"):set_int(0)
    se.get_convar("cl_csm_shadows"):set_int(0)
    se.get_convar("cl_csm_world_shadows"):set_int(0)
    se.get_convar("cl_foot_contact_shadows"):set_int(0)
    se.get_convar("cl_csm_viewmodel_shadows"):set_int(0)
    se.get_convar("cl_csm_rope_shadows"):set_int(0)
    se.get_convar("cl_csm_sprite_shadows"):set_int(0)
    se.get_convar("cl_disablefreezecam"):set_int(1)
    se.get_convar("cl_freezecampanel_position_dynamic"):set_int(0)
    se.get_convar("cl_freezecameffects_showholiday"):set_int(0)
    se.get_convar("cl_showhelp"):set_int(0)
    se.get_convar("cl_autohelp"):set_int(0)
    se.get_convar("cl_disablehtmlmotd"):set_int(1)
    se.get_convar("mat_postprocess_enable"):set_int(0)
    se.get_convar("fog_enable_water_fog"):set_int(0)
    se.get_convar("gameinstructor_enable"):set_int(0)
    se.get_convar("cl_csm_world_shadows_in_viewmodelcascade"):set_int(0)
    se.get_convar("fps_max"):set_int(0)
    se.get_convar("fps_max_menu"):set_int(0)
    se.get_convar("sv_maxusrcmdprocessticks"):set_int(16)
    end)


local tahoma_bold = renderer.setup_font("C:/Windows/Fonts/tahomabd.ttf", 30, 0)
local welcome_user = client.get_username()
local screensize1 = engine.get_screen_size()
local intro_time = globalvars.get_real_time() + 2

math.lerp = function(a, b, t)
    return a + (b - a) * t 
end
local animmg = 0
local on_intro_paint = function ()
    if intro_time < globalvars.get_real_time() then
        return
    end
    local welcome_text = "Welcome back helio.yaw"
    local text_welcome = welcome_text
    animmg = math.lerp(animmg, -50 or 19, 15 * globalvars.get_frame_time())
    local x = screensize1.x / 2
    local y = screensize1.y / 2

    renderer.text(text_welcome, tahoma_bold, vec2_t.new(x - animmg - 200, y), 30, color_t.new(0, 0, 0, 255))
    renderer.text(text_welcome, tahoma_bold, vec2_t.new(x - animmg - 200, y), 30, color_t.new(255, 255, 255, 255))

    renderer.text("uploaded", tahoma_bold, vec2_t.new(x - animmg - 185, y + 30), 30, color_t.new(0, 0, 0, 255))
    renderer.text("uploaded", tahoma_bold, vec2_t.new(x - animmg - 185, y + 30), 30, color_t.new(0, 168, 0, 255))

    renderer.text("successfully", tahoma_bold, vec2_t.new(x - animmg - 60, y + 30), 30, color_t.new(0, 0, 0, 255))
    renderer.text("successfully", tahoma_bold, vec2_t.new(x - animmg - 60, y + 30), 30, color_t.new(255, 255, 255, 255))
end
client.register_callback('paint', on_intro_paint)


local function ping ()
    local spike = ui.get_slider_int("misc_ping_spike_amount")
if ping_enable:is_active() then
    spike:set_value(pin_value:get_value())
else
    spike:set_value(0)
end
end
client.register_callback("create_move", ping)


local hitchance = ui.get_slider_int("rage_scout_hitchance")
local hitchance_nazad = ui.get_slider_int("rage_scout_hitchance"):get_value()


client.register_callback('paint', function()
    localPlayer = entitylist.get_local_player()
    m_hGroundEntity = localPlayer:get_prop_int(se.get_netvar("DT_BasePlayer", "m_hGroundEntity"))

    if jumpscout:get_value() then 
  if m_hGroundEntity == -1 then
    hitchance:set_value(jump_hc:get_value())
  elseif m_hGroundEntity ~= -1 then
    hitchance:set_value(hitchance_nazad)
  end
  end
end)


entity_t.get_weapon_index = function(p)
    local active_weapon = entitylist.get_entity_from_handle(p:get_prop_int(netvars.m_hActiveWeapon)):get_prop_int(netvars.m_iItemDefinitionIndex)
    return active_weapon
end

local active_damage = ui.get_key_bind("rage_min_damage_override_bind")
local function let()
    local players = entitylist.get_players(0)
    for i = 1, #players do
        local player = players[i]
        local helth = player:get_prop_int(se.get_netvar('DT_BasePlayer', 'm_iHealth'))

        if active_damage:is_active() then
        if baim_on_dmg:get_value() then 
            local SCAN_HEAD = 0
            local SCAN_CHEST = 1
            local SCAN_PELVIS = 2
            local SCAN_STOMACH = 3
            local SCAN_LEGS = 4
            local SCAN_FOOT = 5
            
            local entity_index = player:get_index()
            ragebot.override_hitscan(entity_index, SCAN_HEAD, false)
            ragebot.override_hitscan(entity_index, SCAN_CHEST, true)
            ragebot.override_hitscan(entity_index, SCAN_PELVIS, true)
            ragebot.override_hitscan(entity_index, SCAN_STOMACH, false)
            ragebot.override_hitscan(entity_index, SCAN_LEGS, false)
            ragebot.override_hitscan(entity_index, SCAN_FOOT, false)
        end
    end

        if lethal_system:get_value(0) then
if (helth < 89) and entitylist.get_local_player():get_weapon_index() ~= 40 then 
    local SCAN_HEAD = 0
    local SCAN_CHEST = 1
    local SCAN_PELVIS = 2
    local SCAN_STOMACH = 3
    local SCAN_LEGS = 4
    local SCAN_FOOT = 5
    
    local entity_index = player:get_index()
    ragebot.override_hitscan(entity_index, SCAN_HEAD, false)
    ragebot.override_hitscan(entity_index, SCAN_CHEST, true)
    ragebot.override_hitscan(entity_index, SCAN_PELVIS, true)
    ragebot.override_hitscan(entity_index, SCAN_STOMACH, false)
    ragebot.override_hitscan(entity_index, SCAN_LEGS, false)
    ragebot.override_hitscan(entity_index, SCAN_FOOT, false)
end 
end

if lethal_system:get_value(1) then
    if (helth < 89) and entitylist.get_local_player():get_weapon_index() ~= 40 then 
        local entity_index = player:get_index()
        ragebot.override_safe_point(entity_index, 2)
    end
end

end
end
client.register_callback("create_move", let)


function hasbit(x, p) return x % (p + p) >= p end
function checks(cmd) 
    if hasbit(cmd.buttons, bit32.lshift(1, 0)) then
        return true
    end
    if hasbit(cmd.buttons, bit32.lshift(1, 5)) then
        return true
    end
end

client.register_callback("create_move", function(cmd)
    local tick = 15
    local is_pressed = fake_flick_switch_key:is_active()

    if exploit:get_value(0) then
        ui.get_check_box("antihit_fakelag_enable"):set_value(false)
    else
        ui.get_check_box("antihit_fakelag_enable"):set_value(true)
end
if checks(cmd) then return end
    if exploit:get_value(0) then
        if is_pressed then
           if globalvars.get_tick_count() % tick == 0 then
              cmd.viewangles.yaw = cmd.viewangles.yaw + 90
           end
        else
           if globalvars.get_tick_count() % tick == 0 then
              cmd.viewangles.yaw = cmd.viewangles.yaw - 90
           end
        end
    end
end)


local function fake_up ()
localPlayer = entitylist.get_local_player()
m_hGroundEntity = localPlayer:get_prop_int(se.get_netvar("DT_BasePlayer", "m_hGroundEntity"))
local ticker = 15
local pitch = ui.get_combo_box("antihit_antiaim_pitch")
if exploit:get_value(1) then
    if m_hGroundEntity == -1 and globalvars.get_tick_count() % ticker == 0 then
     local pitcher = 1 and 3 
     pitch:set_value(pitcher)
    else
     pitch:set_value(1)
    end
end
end
client.register_callback("create_move", fake_up)


local screen_size = {
    x = engine.get_screen_size().x,
    y = engine.get_screen_size().y
}

local e_menu = {
    PITCH = ui.get_combo_box("antihit_antiaim_pitch"),
    YAW_BASE = ui.get_combo_box("antihit_antiaim_yaw"),
    JITTER_RANGE = ui.get_slider_int("antihit_antiaim_yaw_jitter"),
    DESYNC_TYPE = ui.get_combo_box("antihit_antiaim_desync_type"),
    DESYNC_RANGE = ui.get_slider_int("antihit_antiaim_desync_length"),
}

local e_netvars = {
    m_hmyweapons = 0x2E08,
    m_hactiveweapon = 0x2F08,
    m_iobservermode = 0x3388,
    m_hobservertarget = 0x339C,
    m_iitemdefinitionindex = 0x2FBA,
    m_vecorigin = se.get_netvar("DT_BaseEntity", "m_vecOrigin"),
    m_ihealth = se.get_netvar("DT_BasePlayer", "m_iHealth"),
    m_vecvelocity = se.get_netvar("DT_BasePlayer", "m_vecVelocity[0]"),
    m_fflags = se.get_netvar("DT_BasePlayer", "m_fFlags"),
    m_iteamnum = se.get_netvar("DT_BaseEntity", "m_iTeamNum"),
    m_flnextprimaryattack = se.get_netvar("DT_BaseCombatWeapon", "m_flNextPrimaryAttack"),
    m_ntickbase = se.get_netvar("DT_BasePlayer", "m_nTickBase"),
    m_iclip1 = se.get_netvar("DT_BaseCombatWeapon", "m_iClip1"),
    m_fthrowtime = se.get_netvar("DT_BaseCSGrenade", "m_fThrowTime"),
    m_nrendermode = se.get_netvar("DT_BaseEntity", "m_nRenderMode"),
    m_bdidsmokeeffect = se.get_netvar("DT_SmokeGrenadeProjectile", "m_bDidSmokeEffect"),
    m_bfireisburning = se.get_netvar("DT_Inferno", "m_bFireIsBurning"),
    m_firecount = se.get_netvar("DT_Inferno", "m_fireCount"),
    m_firexdelta = se.get_netvar("DT_Inferno", "m_fireXDelta"),
    m_fireydelta = se.get_netvar("DT_Inferno", "m_fireYDelta"),
    m_firezdelta = se.get_netvar("DT_Inferno", "m_fireZDelta"),
    m_flvelocitymodifier = se.get_netvar("DT_CSPlayer", "m_flVelocityModifier"),
    m_flmodelscale = se.get_netvar("DT_BaseAnimating", "m_flModelScale"),
    m_scaletype = se.get_netvar("DT_BaseAnimating", "m_ScaleType")
}
--- #endregion

--- #region: entity helpers
local entity_c = {}
entity_c.playerinair = function(entity)
    local flags = entity:get_prop_int(e_netvars.m_fflags)

    if (bit.band(flags, bit.lshift(1, 0)) ~= 1) then
        return true
    end

    return false
end
entity_c.playeronground = function(entity)
    local flags = entity:get_prop_int(e_netvars.m_fflags)

    if bit.band(flags, 1) == 1 then
        return true
    end

    return false
end
entity_c.playeroncrouch = function(entity)
    local flags = entity:get_prop_int(e_netvars.m_fflags)

    if bit.band(flags, 4) == 4 then
        return true
    end

    return false
end

entity_c.get_velocity = function(entity)
    local vel = entity:get_prop_vector(e_netvars.m_vecvelocity)
    local speed = math.floor(math.min(10000, math.sqrt(vel.x^2 + vel.y^2) + 0.5))
    
    return speed
end
entity_c.get_condition = function()
    local player = entitylist.get_local_player()

    if (player == nil or player:is_alive() == false) then
        return
    end

    local velocity = entity_c.get_velocity(player)
    local flags = player:get_prop_int(e_netvars.m_fflags)
    local air = entity_c.playerinair(player)
    local crouch = entity_c.playeroncrouch(player)
    local ground = entity_c.playeronground(player)

    if air then
        if crouch then
            return 5
        end

        return 4
    end

    if crouch and air == false or (ui.get_check_box("antihit_fakeduck"):get_value() and ui.get_key_bind("antihit_fakeduck_bind"):is_active()) then
        return 3
    end

    if (velocity > 5) then
        if (ui.get_check_box("antihit_accurate_walk"):get_value() and ui.get_key_bind("antihit_accurate_walk_bind"):is_active()) then
            return 1
        end 
    
        return 2
    end
    
    if ground then
    return 0
    end

end
--- #endregion

local menu = {
    condition = ui.add_combo_box("Condition", "antiaim_condition", {"standing", "walking", "running", "crouch", "air", "air+"}, 0)
}

antiaim = {
    list = {},
    items = {"stand", "walk", "run", "crouch", "air", "air+"},
}

antiaim.create_elements = function()
    for key, value in ipairs(antiaim.items) do
        local function name(text)
            return ("[%s] %s"):format(value, text)
        end
    
        if (antiaim.list[key] == nil) then
            antiaim.list[key] = {}
        end
    
        local setup = antiaim.list[key]
    
        setup.enable_condition = ui.add_check_box(name("Enable"), name("Anti-Aim / enable"), false)
        setup.jitter_type = ui.add_combo_box(name("Jitter Type"), name("Anti-Aim / jitter type"), {"Defult", "Random", "3-WAY"}, 0)
        setup.jitter_value = ui.add_slider_int(name("Jitter Value"), name("Anti-Aim / jitter value"), -90, 90, 0)
        setup.jitter_value_min = ui.add_slider_int(name("Jitter Value Min"), name("Anti-Aim / jitter value min"), -90, 90, 0)
        setup.jitter_value_max = ui.add_slider_int(name("Jitter Value Max"), name("Anti-Aim / jitter value max"), -90, 90, 0)
        setup.firstway_value = ui.add_slider_int(name("WAY 1"), name("Anti-Aim / firstway value"), -90, 90, 0)
        setup.secondway_value = ui.add_slider_int(name("WAY 2"), name("Anti-Aim / secondway value"), -90, 90, 0)
        setup.thirdway_value = ui.add_slider_int(name("WAY 3"), name("Anti-Aim / thirdway value"), -90, 90, 0)

        setup.desync_type = ui.add_combo_box(name("Desync Type"), name("Anti-Aim / desync type"), {"Static", "Jitter", "Random"}, 0)
        setup.desync_lenght_static = ui.add_slider_int(name("Desync Lenght Static"), name("Anti-Aim / desync lenght static"), 0, 60, 0)
        setup.desync_lenght_jitter = ui.add_slider_int(name("Desync Lenght Jitter"), name("Anti-Aim / desync lenght jitter"), 0, 60, 0)
        setup.desync_type_random = ui.add_combo_box(name("Type"), name("Anti-Aim / desync type random"), {"Static", "Jitter"}, 0)
        setup.desync_value_min = ui.add_slider_int(name("Desync Value Min"), name("Anti-Aim / desync value min"), 0, 60, 0)
        setup.desync_value_max = ui.add_slider_int(name("Desync Value Max"), name("Anti-Aim / desync value max"), 0, 60, 0)
    end
end; antiaim.create_elements()


antiaim.modifers = function()
    math.randomseed(os.clock())
    local switch = math.random(0, 10)

    local player = entitylist.get_local_player()

    if (player == nil or not player:is_alive()) then
        return
    end

    local condition = entity_c.get_condition()
    local item = antiaim.list[condition + 1]

    if item.enable_condition:get_value() or ground or (velocity > 5) or (ui.get_check_box("antihit_accurate_walk"):get_value() and ui.get_key_bind("antihit_accurate_walk_bind"):is_active()) or crouch and air == false or (ui.get_check_box("antihit_fakeduck"):get_value() and ui.get_key_bind("antihit_fakeduck_bind"):is_active()) or air or crouch then
        if item.jitter_type:get_value() == 0 then
        e_menu.JITTER_RANGE:set_value(item.jitter_value:get_value())
        end
        if item.jitter_type:get_value() == 1 then
            local int = math.random(item.jitter_value_min:get_value(), item.jitter_value_max:get_value())
            e_menu.JITTER_RANGE:set_value(int)
            end
            if item.jitter_type:get_value() == 2 then
                if switch == 1  then
                    e_menu.JITTER_RANGE:set_value(item.firstway_value:get_value())
                elseif switch == 5  then
                    e_menu.JITTER_RANGE:set_value(item.secondway_value:get_value())
                elseif switch == 9 then
                    e_menu.JITTER_RANGE:set_value(item.thirdway_value:get_value())
                end
                end

                if item.desync_type:get_value() == 0 then
                    e_menu.DESYNC_TYPE:set_value(0)
                    e_menu.DESYNC_RANGE:set_value(item.desync_lenght_static:get_value())
                elseif item.desync_type:get_value() == 1 then
                    e_menu.DESYNC_TYPE:set_value(1)
                    e_menu.DESYNC_RANGE:set_value(item.desync_lenght_jitter:get_value())
                end

                if item.desync_type:get_value() == 2 then
                    e_menu.DESYNC_TYPE:set_value(item.desync_type_random:get_value())
                    local int_des_random = math.random(item.desync_value_min:get_value(), item.desync_value_max:get_value())
                    e_menu.DESYNC_RANGE:set_value(int_des_random)
                end
    end
end
--- #region: callbacks
--- #create_move
client.register_callback("create_move", antiaim.modifers)
--- #endregion
client.register_callback("paint", function()
    if not ui.is_visible() then return end
    local tab_antiaim = tab:get_value()

    -- antiaim
    menu.condition:set_visible(tab_antiaim == 1 and aa_active)

    for key, value in ipairs(antiaim.items) do
        if (antiaim.list[key] == nil) then
            antiaim.list[key] = {}
        end

        local setup = antiaim.list[key]

        local function visible_condition()
            return tab_antiaim == 1 and menu.condition:get_value() == key-1 and setup.enable_condition:get_value()
        end 


        setup.enable_condition:set_visible(tab_antiaim == 1 and menu.condition:get_value() == key-1 and aa_active)
        setup.jitter_type:set_visible(visible_condition() and aa_active)
        setup.jitter_value:set_visible(visible_condition() and setup.jitter_type:get_value() == 0 and aa_active)
        setup.jitter_value_min:set_visible(visible_condition() and setup.jitter_type:get_value() == 1 and aa_active)
        setup.jitter_value_max:set_visible(visible_condition() and setup.jitter_type:get_value() == 1 and aa_active)
        setup.firstway_value:set_visible(visible_condition() and setup.jitter_type:get_value() == 2 and aa_active)
        setup.secondway_value:set_visible(visible_condition() and setup.jitter_type:get_value() == 2 and aa_active)
        setup.thirdway_value:set_visible(visible_condition() and setup.jitter_type:get_value() == 2 and aa_active)

        setup.desync_type:set_visible(visible_condition() and aa_active)
        setup.desync_lenght_static:set_visible(visible_condition() and setup.desync_type:get_value() == 0 and aa_active)
        setup.desync_lenght_jitter:set_visible(visible_condition() and setup.desync_type:get_value() == 1 and aa_active)
        setup.desync_type_random:set_visible(visible_condition() and setup.desync_type:get_value() == 2 and aa_active)
        setup.desync_value_min:set_visible(visible_condition() and setup.desync_type:get_value() == 2 and aa_active)
        setup.desync_value_max:set_visible(visible_condition() and setup.desync_type:get_value() == 2 and aa_active)
    end
end)


local at_target_off = ui.get_check_box("antihit_antiaim_at_targets")
local at_target_off_nazad = ui.get_check_box("antihit_antiaim_at_targets"):get_value()
function off_target ()
if antihit_antiaim_left:is_active() or antihit_antiaim_right:is_active() or exploit:get_value(0) then 
    at_target_off:set_value(false)
    else
    ui.get_check_box("antihit_antiaim_at_targets"):set_value(at_target_off_nazad)
end
end
client.register_callback("create_move", off_target)


flip_bind = ui.get_key_bind("antihit_antiaim_flip_bind")
    client.register_callback("shot_fired", function(shot_info)
        if shot_info.result == "hit" and not shot_info.manual then
           if antibrute:get_value() then
            flip_bind:set_key(0)
                if flip_bind:get_type() == 0 then
                    flip_bind:set_type(1)
                else
                    flip_bind:set_type(0)
                end
            end
        end
        end)

        client.register_callback("shot_fired", function(shot_info)
            if shot_info.result ~= "hit" and not shot_info.manual then
               if antibrute:get_value() then
                flip_bind:set_key(0)
                    if flip_bind:get_type() == 0 then
                        flip_bind:set_type(1)
                    else
                        flip_bind:set_type(0)
                    end
                end
            end
            end)


local manual = 0
local function on_paint()
	if antihit_antiaim_left:is_active() then
        manual = 2
	elseif antihit_antiaim_right:is_active() then
		manual = 3
    else
        manual = 1
	end
	ui.get_combo_box("antihit_antiaim_yaw"):set_value(manual)
end
client.register_callback("paint", on_paint)


math.lerp = function(a, b, percentage)
    return a + (b - a) * percentage
end
color_t.fade_color = function(f, s, a)
    local r = math.lerp(f.red * 255, s.red * 255, a)
    local g = math.lerp(f.green * 255, s.green * 255, a)
    local b = math.lerp(f.blue * 255, s.blue * 255, a)
    local a = math.lerp(f.alpha * 255, s.alpha * 255, a)
    return color_t.new(r, g, b, a)
end
renderer.text_outline = function(text, font, pos, size, color)
    renderer.text(text, font, vec2_t.new(pos.x - 1, pos.y - 0), size, color)
    renderer.text(text, font, vec2_t.new(pos.x - 0, pos.y - 1), size, color)
    renderer.text(text, font, vec2_t.new(pos.x + 1, pos.y + 0), size, color)
    renderer.text(text, font, vec2_t.new(pos.x + 0, pos.y + 1), size, color)
    renderer.text(text, font, vec2_t.new(pos.x - 1, pos.y - 1), size, color)
    renderer.text(text, font, vec2_t.new(pos.x + 1, pos.y + 1), size, color)
    renderer.text(text, font, vec2_t.new(pos.x + -1, pos.y + 1), size, color)
    renderer.text(text, font, vec2_t.new(pos.x - -1, pos.y - 1), size, color)
end

function DrawEnchantedText(speed, text, font, pos, size, color, glow_color)
    local chars_x = 0
    local len = #text - 1
    for i = 1, len + 1 do
        local text_sub = string.sub(text, i, i)
        local text_size = renderer.get_text_size(font, size, text_sub .. "")
        local color_glowing = color_t.fade_color(glow_color, color, math.abs(math.sin((globalvars.get_real_time() - (i * 0.08)) * speed)))
        renderer.text(text_sub .. "", font, vec2_t.new(pos.x + chars_x, pos.y), size, color_glowing)
        chars_x = chars_x + text_size.x
    end
end

function DrawGlowingText(static, text, font, pos, size, color, glow_color)
    local initial_a = 20
    local a_by_i = 2
    local alpha_glow = math.abs(math.sin((globalvars.get_real_time() - 0.1) * 2))
    if static then alpha_glow = 1 end
    for i = 1, 5 do
        renderer.text_outline(text, font, pos, size, color_t.new(glow_color.red * 255, glow_color.green * 255, glow_color.blue * 255, ((initial_a - (i * a_by_i)) * alpha_glow)))
    end
    renderer.text(text, font, pos, size, color)
end


local Cambridge = renderer.setup_font("C:/Windows/Fonts/verdana.ttf", 12, 128 + 16)
local username = client.get_username()
local screensize = engine.get_screen_size()

local function paint()
    if windows_ui:get_value(0) then
    local cheatname = "helio.yaw [debug]"
    ui.get_check_box("visuals_watermark"):set_value(false)
    local time = os.date("%H:%M")
    local ping = se.get_latency()
    local text = cheatname .. " | " .. username .. " | " ..ping.. "ms | ".. time 
    local text_size = renderer.get_text_size(Cambridge, 12, text)
    local x = screensize.x - text_size.x - 15
    local y = 10
    local h = 18

    renderer.rect_filled(vec2_t.new(x, y + 2), vec2_t.new(x+text_size.x + 8, 12+h), color_back:get_value())
    if souls:get_value() == 0 then
    renderer.rect_filled(vec2_t.new(x, y), vec2_t.new(x+text_size.x + 8, y+2), col:get_value())
    end
    if souls:get_value() == 1 then
        renderer.rect_filled(vec2_t.new(x+text_size.x + 8, y+2), vec2_t.new(x+text_size.x + 9, y+20), color_back:get_value())
        renderer.rect_filled(vec2_t.new(x, y+2), vec2_t.new(x-1, y+20), color_back:get_value())

        renderer.rect_filled(vec2_t.new(x, y+1), vec2_t.new(x+text_size.x + 8, y+2), col:get_value()) --left
        renderer.rect_filled(vec2_t.new(x, y+2), vec2_t.new(x-1, y+3), col:get_value()) --left
        renderer.rect_filled(vec2_t.new(x-2, y+3), vec2_t.new(x-1, y+20), col:get_value()) --left

        renderer.rect_filled(vec2_t.new(x+text_size.x + 8, y+2), vec2_t.new(x+text_size.x + 9, y+3), col:get_value()) --right
        renderer.rect_filled(vec2_t.new(x+text_size.x + 9, y+3), vec2_t.new(x+text_size.x + 10, y+20), col:get_value()) --right
        end

    renderer.text( text, Cambridge, vec2_t.new(x+4, y+5), 12, color_t.new(0, 0, 0, 255))
    renderer.text( text, Cambridge, vec2_t.new(x+4, y+4), 12, color_t.new(255, 255, 255, 255))
    end
end
client.register_callback("paint", paint)


ffi.cdef([[
    short GetAsyncKeyState(int vKey);
]])
extended = {
    ["key_press"] = function(key)
        local result = ffi.C.GetAsyncKeyState(key)
        return result ~= 0 and bit.band(result, 0x8000) ~= 0
    end,
}

local screen = engine.get_screen_size()
--- #region: drag
local draggable = { mouse_target = "", hovering = "" }
draggable.__index = draggable
draggable.num = 1
function draggable.new(name)
    local self = setmetatable({}, draggable)
    self.position_x = ui.add_slider_int(name .. "_x", name .. "_x", 0, screen.x, 160 * draggable.num)
    self.position_y = ui.add_slider_int(name .. "_y", name .. "_y", 0, screen.y, 80)
    self.size_x = ui.add_slider_int(name .. "_w", name .. "_w", 0, screen.x, 128)
    self.size_y = ui.add_slider_int(name .. "_h", name .. "_h", 0, screen.y, 22)
    self.name = name
    self.started_dragging = false
    self.initial_drag_pos = vec2_t.new(0, 0)
    self.drag_pos = vec2_t.new(0, 0)
    self.position_x:set_visible(false)
    self.position_y:set_visible(false)
    self.size_x:set_visible(false)
    self.size_y:set_visible(false)
    draggable.num = draggable.num + 1
    return self
end
function draggable:handle(new_size_x, new_size_y)
    self.size_x:set_value(new_size_x or self.size_x:get_value())
    self.size_y:set_value(new_size_y or self.size_y:get_value())
    local position_x = self.position_x:get_value()
    local position_y = self.position_y:get_value()
    local size_x = self.size_x:get_value()
    local size_y = self.size_y:get_value()
    if ui.is_visible() then
        local mouse_position = renderer.get_cursor_pos()
        local is_in_bounds =
        (mouse_position.x >= position_x and mouse_position.y >= position_y and
            mouse_position.x <= position_x + size_x and
            mouse_position.y <= position_y + size_y)

        if (is_in_bounds and draggable.hovering == self.name) or draggable.mouse_target == self.name then
            renderer.rect_filled(
                vec2_t.new(position_x, position_y),
                vec2_t.new(position_x + size_x, position_y + size_y),
                color_t.new(255, 255, 255, 0)
            )
        end

        if is_in_bounds and draggable.mouse_target == "" and
            (draggable.hovering == "" or draggable.hovering == self.name) then
            draggable.hovering = self.name
        elseif draggable.hovering == self.name and draggable.mouse_target ~= self.name then
            draggable.hovering = ""
        end
        if (is_in_bounds or self.started_dragging) and extended.key_press(1) and
            (draggable.mouse_target == "" or draggable.mouse_target == self.name) and
            draggable.hovering == self.name
        then
            draggable.mouse_target = self.name
            if not self.started_dragging then
                self.started_dragging = true
                self.initial_drag_pos =
                vec2_t.new(mouse_position.x - position_x, mouse_position.y - position_y)
            else
                position_x = mouse_position.x - self.initial_drag_pos.x
                position_y = mouse_position.y - self.initial_drag_pos.y

                self.position_x:set_value(math.max(0, math.min(position_x, screen.x - size_x)))
                self.position_y:set_value(math.max(0, math.min(position_y, screen.y - size_y)))
            end
        elseif self.started_dragging and not extended.key_press(1) then
            self.started_dragging = false
            draggable.mouse_target = ""
        end
    end
end
function draggable:get_pos()
    return self.position_x:get_value(), self.position_y:get_value()
end
function draggable:get_size()
    return vec2_t.new(self.size_x:get_value(), self.size_y:get_value())
end
function draggable:set_name(name)
    self.name = name
end
--- #endregion

local types = {"always", "holding", "disable", "toggled", "disable", "disable"}
local keybind_font = renderer.setup_font("C:/Windows/Fonts/verdana.ttf", 12, 128 + 16)
local keybind = {}
keybind.dragging = draggable.new("test")
keybind.handle = function()
    if windows_ui:get_value(1) then
    local x, y = keybind.dragging:get_pos()
	add_yx = 0
	dt_keybind = ui.get_key_bind("rage_doubletap_bind")
	hs_keybind = ui.get_key_bind("rage_hide_shots_bind")
	min_keybind = ui.get_key_bind("rage_min_damage_override_bind")
	duck_keybind = ui.get_key_bind("antihit_fakeduck_bind")
    auto_keybind = ui.get_key_bind("antihit_autopeek_bind")
    slow_keybind = ui.get_key_bind("antihit_accurate_walk_bind")
    hitscane = ui.get_key_bind("rage_hitscan_override_bind")

    if dt_keybind:is_active() or hs_keybind:is_active() or min_keybind:is_active() or duck_keybind:is_active() or auto_keybind:is_active() or slow_keybind:is_active() or antihit_antiaim_left:is_active() or antihit_antiaim_right:is_active() or hitscane:is_active() then
    renderer.rect_filled(vec2_t.new(x - 1, y), vec2_t.new(x + 130, y + 17), color_back:get_value())
    end

    if souls:get_value() == 0 then
    if dt_keybind:is_active() or hs_keybind:is_active() or min_keybind:is_active() or duck_keybind:is_active() or auto_keybind:is_active() or slow_keybind:is_active() or antihit_antiaim_left:is_active() or antihit_antiaim_right:is_active() or hitscane:is_active() then
	renderer.rect_filled(vec2_t.new(x - 1, y), vec2_t.new(x + 130, y + 2), col:get_value())
    end

    end
    if souls:get_value() == 1 then
        if dt_keybind:is_active() or hs_keybind:is_active() or min_keybind:is_active() or duck_keybind:is_active() or auto_keybind:is_active() or slow_keybind:is_active() or antihit_antiaim_left:is_active() or antihit_antiaim_right:is_active() or hitscane:is_active() then
        renderer.rect_filled(vec2_t.new(x - 1, y), vec2_t.new(x + 130, y + 1), col:get_value())

        renderer.rect_filled(vec2_t.new(x - 2, y + 1), vec2_t.new(x - 1, y + 2), col:get_value())
        renderer.rect_filled(vec2_t.new(x - 3, y + 2), vec2_t.new(x - 2, y + 17), col:get_value())
        renderer.rect_filled(vec2_t.new(x - 2, y + 2), vec2_t.new(x - 1, y + 17), color_back:get_value())

        renderer.rect_filled(vec2_t.new(x + 130, y + 1), vec2_t.new(x + 131, y + 2), col:get_value())
        renderer.rect_filled(vec2_t.new(x + 131, y + 2), vec2_t.new(x + 132, y + 17), col:get_value())
        renderer.rect_filled(vec2_t.new(x + 130, y + 2), vec2_t.new(x + 131, y + 17), color_back:get_value())
        end
        end
        
        if dt_keybind:is_active() or hs_keybind:is_active() or min_keybind:is_active() or duck_keybind:is_active() or auto_keybind:is_active() or slow_keybind:is_active() or antihit_antiaim_left:is_active() or antihit_antiaim_right:is_active() or hitscane:is_active() then
	renderer.text("keybinds", keybind_font, vec2_t.new(x + 40, y + 3), 12, color_t.new(255, 255, 255, 255))
        end

	if dt_keybind:is_active() then
	add_yx = add_yx + 13
	renderer.text("Double tap", keybind_font, vec2_t.new(x, y + 6 + add_yx), 12, color_t.new(0, 0, 0, 255))
	renderer.text("Double tap", keybind_font, vec2_t.new(x, y + 5 + add_yx), 12, color_t.new(255, 255, 255, 255))
	renderer.text("["..types[dt_keybind:get_type() + 1].."]", keybind_font, vec2_t.new(x + 78, y + 6 + add_yx), 12, color_t.new(0, 0, 0, 255))
	renderer.text("["..types[dt_keybind:get_type() + 1].."]", keybind_font, vec2_t.new(x + 78, y + 5 + add_yx), 12, color_t.new(255, 255, 255, 255))
	end

	if hs_keybind:is_active() then
		add_yx = add_yx + 13
		renderer.text("Hide shots", keybind_font, vec2_t.new(x, y + 6 + add_yx), 12, color_t.new(0, 0, 0, 255))
		renderer.text("Hide shots", keybind_font, vec2_t.new(x, y + 5 + add_yx), 12, color_t.new(255, 255, 255, 255))
		renderer.text("["..types[hs_keybind:get_type() + 1].."]", keybind_font, vec2_t.new(x + 78, y + 6 + add_yx), 12, color_t.new(0, 0, 0, 255))
		renderer.text("["..types[hs_keybind:get_type() + 1].."]", keybind_font, vec2_t.new(x + 78, y + 5 + add_yx), 12, color_t.new(255, 255, 255, 255))
		end

		if min_keybind:is_active() then
			add_yx = add_yx + 13
			renderer.text("Min damage", keybind_font, vec2_t.new(x, y + 6 + add_yx), 12, color_t.new(0, 0, 0, 255))
			renderer.text("Min damage", keybind_font, vec2_t.new(x, y + 5 + add_yx), 12, color_t.new(255, 255, 255, 255))
			renderer.text("["..types[min_keybind:get_type() + 1].."]", keybind_font, vec2_t.new(x + 78, y + 6 + add_yx), 12, color_t.new(0, 0, 0, 255))
			renderer.text("["..types[min_keybind:get_type() + 1].."]", keybind_font, vec2_t.new(x + 78, y + 5 + add_yx), 12, color_t.new(255, 255, 255, 255))
			end

			if duck_keybind:is_active() then
				add_yx = add_yx + 13
				renderer.text("Fake duck", keybind_font, vec2_t.new(x, y + 6 + add_yx), 12, color_t.new(0, 0, 0, 255))
				renderer.text("Fake duck", keybind_font, vec2_t.new(x, y + 5 + add_yx), 12, color_t.new(255, 255, 255, 255))
				renderer.text("["..types[duck_keybind:get_type() + 1].."]", keybind_font, vec2_t.new(x + 78, y + 6 + add_yx), 12, color_t.new(0, 0, 0, 255))
				renderer.text("["..types[duck_keybind:get_type() + 1].."]", keybind_font, vec2_t.new(x + 78, y + 5 + add_yx), 12, color_t.new(255, 255, 255, 255))
				end

                if auto_keybind:is_active() then
                    add_yx = add_yx + 13
                    renderer.text("Autopeek", keybind_font, vec2_t.new(x, y + 6 + add_yx), 12, color_t.new(0, 0, 0, 255))
                    renderer.text("Autopeek", keybind_font, vec2_t.new(x, y + 5 + add_yx), 12, color_t.new(255, 255, 255, 255))
                    renderer.text("["..types[auto_keybind:get_type() + 1].."]", keybind_font, vec2_t.new(x + 78, y + 6 + add_yx), 12, color_t.new(0, 0, 0, 255))
                    renderer.text("["..types[auto_keybind:get_type() + 1].."]", keybind_font, vec2_t.new(x + 78, y + 5 + add_yx), 12, color_t.new(255, 255, 255, 255))
                    end

                    if slow_keybind:is_active() then
                        add_yx = add_yx + 13
                        renderer.text("Slow walk", keybind_font, vec2_t.new(x, y + 6 + add_yx), 12, color_t.new(0, 0, 0, 255))
                        renderer.text("Slow walk", keybind_font, vec2_t.new(x, y + 5 + add_yx), 12, color_t.new(255, 255, 255, 255))
                        renderer.text("["..types[slow_keybind:get_type() + 1].."]", keybind_font, vec2_t.new(x + 78, y + 6 + add_yx), 12, color_t.new(0, 0, 0, 255))
                        renderer.text("["..types[slow_keybind:get_type() + 1].."]", keybind_font, vec2_t.new(x + 78, y + 5 + add_yx), 12, color_t.new(255, 255, 255, 255))
                        end

                        if antihit_antiaim_left:is_active() then
                            add_yx = add_yx + 13
                            renderer.text("Manual left", keybind_font, vec2_t.new(x, y + 6 + add_yx), 12, color_t.new(0, 0, 0, 255))
                            renderer.text("Manual left", keybind_font, vec2_t.new(x, y + 5 + add_yx), 12, color_t.new(255, 255, 255, 255))
                            renderer.text("["..types[antihit_antiaim_left:get_type() + 1].."]", keybind_font, vec2_t.new(x + 78, y + 6 + add_yx), 12, color_t.new(0, 0, 0, 255))
                            renderer.text("["..types[antihit_antiaim_left:get_type() + 1].."]", keybind_font, vec2_t.new(x + 78, y + 5 + add_yx), 12, color_t.new(255, 255, 255, 255))
                            end

                            if antihit_antiaim_right:is_active() then
                                add_yx = add_yx + 13
                                renderer.text("Manual right", keybind_font, vec2_t.new(x, y + 6 + add_yx), 12, color_t.new(0, 0, 0, 255))
                                renderer.text("Manual right", keybind_font, vec2_t.new(x, y + 5 + add_yx), 12, color_t.new(255, 255, 255, 255))
                                renderer.text("["..types[antihit_antiaim_right:get_type() + 1].."]", keybind_font, vec2_t.new(x + 78, y + 6 + add_yx), 12, color_t.new(0, 0, 0, 255))
                                renderer.text("["..types[antihit_antiaim_right:get_type() + 1].."]", keybind_font, vec2_t.new(x + 78, y + 5 + add_yx), 12, color_t.new(255, 255, 255, 255))
                                end
                                if hitscane:is_active() then
                                    add_yx = add_yx + 13
                                    renderer.text("Body aim", keybind_font, vec2_t.new(x, y + 6 + add_yx), 12, color_t.new(0, 0, 0, 255))
                                    renderer.text("Body aim", keybind_font, vec2_t.new(x, y + 5 + add_yx), 12, color_t.new(255, 255, 255, 255))
                                    renderer.text("["..types[hitscane:get_type() + 1].."]", keybind_font, vec2_t.new(x + 78, y + 6 + add_yx), 12, color_t.new(0, 0, 0, 255))
                                    renderer.text("["..types[hitscane:get_type() + 1].."]", keybind_font, vec2_t.new(x + 78, y + 5 + add_yx), 12, color_t.new(255, 255, 255, 255))
                            end
                                ui.get_check_box("visuals_keybinds"):set_value(false)
                    end
    keybind.dragging:handle(130, 17)
end
client.register_callback("paint", keybind.handle)


local slowWalkBint = ui.get_key_bind("antihit_accurate_walk_bind")
local m_bDucked = se.get_netvar("DT_BasePlayer", "m_bDucked")
local m_vecVelocity = {
    [0] = se.get_netvar("DT_BasePlayer", "m_vecVelocity[0]"),
    [1] = se.get_netvar("DT_BasePlayer", "m_vecVelocity[1]")
}

local ind = renderer.setup_font("C:/helio/smallestpixel.ttf", 10, 128)
local screensize = {}
screensize.x = engine.get_screen_size().x / 2
screensize.y = engine.get_screen_size().y / 2
math.lerp = function(a, b, t)
    return a + (b - a) * t 
end
local animmg = 0
local function on_paint()
    local self = entitylist.get_local_player()
    if not self or not self:is_alive() then
        return
    end

    localPlayer = entitylist.get_local_player()
    m_hGroundEntity = localPlayer:get_prop_int(se.get_netvar("DT_BasePlayer", "m_hGroundEntity"))
    duck = localPlayer:get_prop_int(se.get_netvar("DT_BasePlayer", "m_bDucked"))
    velocity = math.sqrt(localPlayer:get_prop_float(m_vecVelocity[0]) ^ 2 + localPlayer:get_prop_float(m_vecVelocity[1]) ^ 2)

    local netvar = se.get_netvar("DT_CSPlayer", "m_bIsScoped")
    local m_bIsScoped = self:get_prop_bool(netvar)
    animmg = math.lerp(animmg, m_bIsScoped and -25 or 19, 10 * globalvars.get_frame_time())
    if windows_ui:get_value(2) and engine.is_connected() then
    add_yx = 0
    dt_indi = ui.get_key_bind("rage_doubletap_bind")
    hs_indi = ui.get_key_bind("rage_hide_shots_bind") 
    min_indi = ui.get_key_bind("rage_min_damage_override_bind")
    baim_indi = ui.get_key_bind("rage_hitscan_override_bind")


        DrawGlowingText(true, "HELIO.YAW", ind, vec2_t.new(screensize.x - animmg + 1, screensize.y + 20), 10, color_t.new(0, 0, 0, 255), color_t.new(0, 0, 0, 255))
        DrawGlowingText(true, "HELIO.YAW", ind, vec2_t.new(screensize.x - animmg + 1, screensize.y + 20), 10, color_t.new(0, 0, 0, 255), color_t.new(0, 0, 0, 255))
        DrawEnchantedText(1, "HELIO.YAW", ind, vec2_t.new(screensize.x - animmg + 1, screensize.y + 20), 10, col:get_value(), color_t.new(255, 255, 255, 255))
    if m_hGroundEntity == -1 and duck == 1 then
        add_yx = add_yx + 10 
        DrawGlowingText(true, "-air+-", ind, vec2_t.new(screensize.x - 1 - animmg + 9, screensize.y + 20 + add_yx), 10, color_t.new(0, 0, 0, 255), color_t.new(0, 0, 0, 255))
        DrawGlowingText(true, "-air+-", ind, vec2_t.new(screensize.x - 1 - animmg + 9, screensize.y + 20 + add_yx), 10, color_t.new(0, 0, 0, 255), color_t.new(0, 0, 0, 255))
        renderer.text("-air+-", ind, vec2_t.new(screensize.x - 1 - animmg + 9, screensize.y + 20 + add_yx), 10, color_t.new(255, 255, 255, 255))
    elseif m_hGroundEntity == -1 then
        add_yx = add_yx + 10 
            DrawGlowingText(true, "-air-", ind, vec2_t.new(screensize.x - animmg + 9, screensize.y + 20 + add_yx), 10, color_t.new(0, 0, 0, 255), color_t.new(0, 0, 0, 255))
            DrawGlowingText(true, "-air-", ind, vec2_t.new(screensize.x - animmg + 9, screensize.y + 20 + add_yx), 10, color_t.new(0, 0, 0, 255), color_t.new(0, 0, 0, 255))
            renderer.text("-air-", ind, vec2_t.new(screensize.x - animmg + 9, screensize.y + 20 + add_yx), 10, color_t.new(255, 255, 255, 255))
    elseif m_hGroundEntity ~= -1 and duck == 1 then
        add_yx = add_yx + 10 
            DrawGlowingText(true, "-crouch-", ind, vec2_t.new(screensize.x - animmg + 2, screensize.y + 20 + add_yx), 10, color_t.new(0, 0, 0, 255), color_t.new(0, 0, 0, 255))
            DrawGlowingText(true, "-crouch-", ind, vec2_t.new(screensize.x - animmg + 2, screensize.y + 20 + add_yx), 10, color_t.new(0, 0, 0, 255), color_t.new(0, 0, 0, 255))
            renderer.text("-crouch-", ind, vec2_t.new(screensize.x - animmg + 2, screensize.y + 20 + add_yx), 10, color_t.new(255, 255, 255, 255))
    elseif m_hGroundEntity ~= -1 and velocity > 5 then
            if not slowWalkBint:is_active() then
                add_yx = add_yx + 10 
                DrawGlowingText(true, "-run-", ind, vec2_t.new(screensize.x - animmg + 9, screensize.y + 20 + add_yx), 10, color_t.new(0, 0, 0, 255), color_t.new(0, 0, 0, 255))
                DrawGlowingText(true, "-run-", ind, vec2_t.new(screensize.x - animmg + 9, screensize.y + 20 + add_yx), 10, color_t.new(0, 0, 0, 255), color_t.new(0, 0, 0, 255))
                renderer.text("-run-", ind, vec2_t.new(screensize.x - animmg + 9, screensize.y + 20 + add_yx), 10, color_t.new(255, 255, 255, 255))
            else
                add_yx = add_yx + 10 
                    DrawGlowingText(true, "-walk-", ind, vec2_t.new(screensize.x - animmg + 6, screensize.y + 20 + add_yx), 10, color_t.new(0, 0, 0, 255), color_t.new(0, 0, 0, 255))
                    DrawGlowingText(true, "-walk-", ind, vec2_t.new(screensize.x - animmg + 6, screensize.y + 20 + add_yx), 10, color_t.new(0, 0, 0, 255), color_t.new(0, 0, 0, 255))
                    renderer.text("-walk-", ind, vec2_t.new(screensize.x - animmg + 6, screensize.y + 20 + add_yx), 10, color_t.new(255, 255, 255, 255))
            end
        elseif m_hGroundEntity ~= -1 and velocity < 5 then
                add_yx = add_yx + 10 
                    DrawGlowingText(true, "-stand-", ind, vec2_t.new(screensize.x - animmg + 5, screensize.y + 20 + add_yx), 10, color_t.new(0, 0, 0, 255), color_t.new(0, 0, 0, 255))
                    DrawGlowingText(true, "-stand-", ind, vec2_t.new(screensize.x - animmg + 5, screensize.y + 20 + add_yx), 10, color_t.new(0, 0, 0, 255), color_t.new(0, 0, 0, 255))
                    renderer.text("-stand-", ind, vec2_t.new(screensize.x - animmg + 5, screensize.y + 20 + add_yx), 10, color_t.new(255, 255, 255, 255))
                end

    if dt_indi:is_active() then
        add_yx = add_yx + 10 
        if styles:get_value() == 0 then
            DrawGlowingText(true, "dt", ind, vec2_t.new(screensize.x + 16 - animmg , screensize.y + 20 + add_yx), 10, color_t.new(0, 0, 0, 255), color_t.new(0, 0, 0, 255))
            DrawGlowingText(true, "dt", ind, vec2_t.new(screensize.x + 16 - animmg , screensize.y + 20 + add_yx), 10, color_t.new(0, 0, 0, 255), color_t.new(0, 0, 0, 255))
            renderer.text("dt", ind, vec2_t.new(screensize.x + 16 - animmg , screensize.y + 20 + add_yx), 10, color_t.new(255, 255, 255, 255))
        else
            DrawGlowingText(true, "DOUBLETAP", ind, vec2_t.new(screensize.x - animmg, screensize.y + 20 + add_yx), 10, color_t.new(0, 0, 0, 255), color_t.new(0, 0, 0, 255))
            DrawGlowingText(true, "DOUBLETAP", ind, vec2_t.new(screensize.x - animmg , screensize.y + 20 + add_yx), 10, color_t.new(0, 0, 0, 255), color_t.new(0, 0, 0, 255))
            renderer.text("DOUBLETAP", ind, vec2_t.new(screensize.x - animmg , screensize.y + 20 + add_yx), 10, color_t.new(255, 255, 255, 255))
        end
        end

if hs_indi:is_active() then 
    add_yx = add_yx + 10 
    if styles:get_value() == 0 then
        DrawGlowingText(true, "hs", ind, vec2_t.new(screensize.x + 16 - animmg, screensize.y + 20 + add_yx), 10, color_t.new(0, 0, 0, 255), color_t.new(0, 0, 0, 255))
        DrawGlowingText(true, "hs", ind, vec2_t.new(screensize.x + 16 - animmg, screensize.y + 20 + add_yx), 10, color_t.new(0, 0, 0, 255), color_t.new(0, 0, 0, 255))
        renderer.text("hs", ind, vec2_t.new(screensize.x + 16 - animmg, screensize.y + 20 + add_yx), 10, color_t.new(255, 255, 255, 255))
    else
        DrawGlowingText(true, "HIDESHOTS", ind, vec2_t.new(screensize.x - animmg, screensize.y + 20 + add_yx), 10, color_t.new(0, 0, 0, 255), color_t.new(0, 0, 0, 255))
        DrawGlowingText(true, "HIDESHOTS", ind, vec2_t.new(screensize.x - animmg, screensize.y + 20 + add_yx), 10, color_t.new(0, 0, 0, 255), color_t.new(0, 0, 0, 255))
        renderer.text("HIDESHOTS", ind, vec2_t.new(screensize.x - animmg, screensize.y + 20 + add_yx), 10, color_t.new(255, 255, 255, 255))
    end
    end


if min_indi:is_active() then 
    add_yx = add_yx + 10 
    if styles:get_value() == 0 then
        DrawGlowingText(true, "dmg", ind, vec2_t.new(screensize.x + 13 - animmg, screensize.y + 20 + add_yx), 10, color_t.new(0, 0, 0, 255), color_t.new(0, 0, 0, 255))
        DrawGlowingText(true, "dmg", ind, vec2_t.new(screensize.x + 13 - animmg, screensize.y + 20 + add_yx), 10, color_t.new(0, 0, 0, 255), color_t.new(0, 0, 0, 255))
        renderer.text("dmg", ind, vec2_t.new(screensize.x + 13 - animmg, screensize.y + 20 + add_yx), 10, color_t.new(255, 255, 255, 255))
    else
        DrawGlowingText(true, "min damage", ind, vec2_t.new(screensize.x - 17 - animmg + 13, screensize.y + 20 + add_yx), 10, color_t.new(0, 0, 0, 255), color_t.new(0, 0, 0, 255))
        DrawGlowingText(true, "min damage", ind, vec2_t.new(screensize.x - 17 - animmg + 13, screensize.y + 20 + add_yx), 10, color_t.new(0, 0, 0, 255), color_t.new(0, 0, 0, 255))
            renderer.text("min damage", ind, vec2_t.new(screensize.x - 17 - animmg + 13, screensize.y + 20 + add_yx), 10, color_t.new(255, 255, 255, 255))
    end
end
    if baim_indi:is_active() then 
        add_yx = add_yx + 10 
        if styles:get_value() == 0 then
            DrawGlowingText(true, "baim", ind, vec2_t.new(screensize.x - 4 - animmg + 13, screensize.y + 20 + add_yx), 10, color_t.new(0, 0, 0, 255), color_t.new(0, 0, 0, 255))
            DrawGlowingText(true, "baim", ind, vec2_t.new(screensize.x - 4 - animmg + 13, screensize.y + 20 + add_yx), 10, color_t.new(0, 0, 0, 255), color_t.new(0, 0, 0, 255))
                renderer.text("baim", ind, vec2_t.new(screensize.x - 4 - animmg + 13, screensize.y + 20 + add_yx), 10, color_t.new(255, 255, 255, 255))
        else
            DrawGlowingText(true, "body aim", ind, vec2_t.new(screensize.x - 11 - animmg + 13, screensize.y + 20 + add_yx), 10, color_t.new(0, 0, 0, 255), color_t.new(0, 0, 0, 255))
            DrawGlowingText(true, "body aim", ind, vec2_t.new(screensize.x - 11 - animmg + 13, screensize.y + 20 + add_yx), 10, color_t.new(0, 0, 0, 255), color_t.new(0, 0, 0, 255))
                renderer.text("body aim", ind, vec2_t.new(screensize.x - 11 - animmg + 13, screensize.y + 20 + add_yx), 10, color_t.new(255, 255, 255, 255))
        end
    end
    end
end

client.register_callback("paint", on_paint)

local inverter_manual = ui.get_key_bind("antihit_antiaim_flip_bind"):is_active()
local arrow_viv = se.get_netvar("DT_BasePlayer", "m_iHealth")
local tahoma_bold = renderer.setup_font("C:/helio/Arrows.ttf", 50, 0)
local palka2 = renderer.setup_font("C:/Windows/Fonts/verdana.ttf", 23, 0)
local screensize_left = engine.get_screen_size()
local screensize_right = engine.get_screen_size()

local function arrow_left()
    if windows_ui:get_value(3) and engine.is_connected() then
    local arrow_vi = entitylist.get_local_player():get_prop_int(arrow_viv)
    if arrow_vi == 0 then return end

    local xl = screensize_left.x / 2
    local yl = screensize_left.y / 2

    local xr = screensize_right.x / 2
    local yr = screensize_right.y / 2

if antihit_antiaim_left:is_active() then
    renderer.text("R", tahoma_bold, vec2_t.new(xl - 55, yl - 19), 50, col:get_value())
end

if antihit_antiaim_right:is_active() then
    renderer.text("Q", tahoma_bold, vec2_t.new(xr + 40, yr - 19), 50, col:get_value())
end
end
end
client.register_callback("paint", arrow_left)


local vvpanel = se.get_netvar("DT_BasePlayer", "m_iHealth")
local font15677 = renderer.setup_font("C:/Windows/Fonts/verdana.ttf", 12, 128 + 16)
local icone = renderer.setup_font("C:/helio/undefeated.ttf", 30, 0)

local numb = ui.get_slider_int("antihit_antiaim_desync_length")
local name = client.get_username()
local screensize = engine.get_screen_size()
local function paint()
    if windows_ui:get_value(4) and engine.is_connected() then
        local des_tipe = ui.get_combo_box("antihit_antiaim_desync_type"):get_value()
        local state_text = "helio.yaw"
        local state_version = "version: debug"
        local text_state = "user: "..name
        local size_state = renderer.get_text_size(font15677, 12, text_state)
        local x = screensize.x - size_state.x / 2
        local y = screensize.y / 2
local vpanel = entitylist.get_local_player():get_prop_int(vvpanel)
if vpanel == 0 then return end
renderer.rect_filled(vec2_t.new(x - x + 10, y - 5), vec2_t.new(x - x + size_state.x + 80, y + 43), color_back:get_value())
if souls:get_value() == 0 then
    renderer.rect_filled(vec2_t.new(x - x + 10, y - 5), vec2_t.new(x - x + size_state.x + 80, y - 3), col:get_value())
end
if souls:get_value() == 1 then
    renderer.rect_filled(vec2_t.new(9, y - 3), vec2_t.new(10, y + 43), color_back:get_value())
    renderer.rect_filled(vec2_t.new(x - x + size_state.x + 80, y - 3), vec2_t.new(x - x + size_state.x + 81, y + 43), color_back:get_value())

    renderer.rect_filled(vec2_t.new(x - x + 10, y - 5), vec2_t.new(x - x + size_state.x + 80, y - 4), col:get_value())

    renderer.rect_filled(vec2_t.new(9, y - 4), vec2_t.new(10, y - 3), col:get_value())
    renderer.rect_filled(vec2_t.new(8, y - 3), vec2_t.new(9, y + 43), col:get_value())

    renderer.rect_filled(vec2_t.new(x - x + size_state.x + 80, y - 4), vec2_t.new(x - x + size_state.x + 81, y - 3), col:get_value())
    renderer.rect_filled(vec2_t.new(x - x + size_state.x + 81, y - 3), vec2_t.new(x - x + size_state.x + 82, y + 43), col:get_value())
end
        renderer.text(state_text, font15677, vec2_t.new(x - x + 55, y + 1), 12, color_t.new(0, 0, 0, 255))
        renderer.text(state_text, font15677, vec2_t.new(x - x + 55, y), 12, color_t.new(255, 255, 255, 255))

        renderer.text(text_state, font15677, vec2_t.new(x - x + 55, y + 13), 12, color_t.new(0, 0, 0, 255))
        renderer.text(text_state, font15677, vec2_t.new(x - x + 55, y + 12), 12, color_t.new(255, 255, 255, 255))

        renderer.text(state_version, font15677, vec2_t.new(x - x + 55, y + 24), 12, color_t.new(0, 0, 0, 255))
        renderer.text(state_version, font15677, vec2_t.new(x - x + 55, y + 23), 12, color_t.new(255, 255, 255, 255))

        renderer.text("v", icone, vec2_t.new(x - x + 15, y + 3), 30, color_t.new(255, 255, 255, 255))
end
end
client.register_callback("paint", paint)


local hitmark_font = renderer.setup_font('c:/windows/fonts/verdana.ttf', 11, 400)

local shots = {}

local function draw_shot(x, y, alpha, damage)
    if damage > 0 then
        renderer.line(vec2_t.new(x - 4, y - 4), vec2_t.new(x - 1, y - 1), col_hit:get_value())
        renderer.line(vec2_t.new(x - 4, y + 4), vec2_t.new(x - 1, y + 1), col_hit:get_value())
        renderer.line(vec2_t.new(x + 1, y - 1), vec2_t.new(x + 4, y - 4), col_hit:get_value())
        renderer.line(vec2_t.new(x + 4, y + 4), vec2_t.new(x + 1, y + 1), col_hit:get_value())
        if text_hit_miss:get_value(0) then
        renderer.text("hit", hitmark_font, vec2_t.new(x + 10, y - 6), 11, col_hit:get_value())
        end
    else if damage == 0 then
        renderer.line(vec2_t.new(x - 4, y - 4), vec2_t.new(x - 1, y - 1), col_miss:get_value())
        renderer.line(vec2_t.new(x - 4, y + 4), vec2_t.new(x - 1, y + 1), col_miss:get_value())
        renderer.line(vec2_t.new(x + 1, y - 1), vec2_t.new(x + 4, y - 4), col_miss:get_value())
        renderer.line(vec2_t.new(x + 4, y + 4), vec2_t.new(x + 1, y + 1), col_miss:get_value())
        if text_hit_miss:get_value(1) then
        renderer.text("miss", hitmark_font, vec2_t.new(x + 10, y - 6), 11, col_miss:get_value())
        end
   end
end
end

local function morgenhit_render()
    if not is_enabled:get_value() then return end

    local realtime = globalvars.get_real_time()

    for i = 1, #shots do
        if shots[i] == nil then return end
        local shot = shots[i]

        local vec = se.world_to_screen(
            vec3_t.new(shot.position.x, shot.position.y, shot.position.z)
        )

        local x = vec.x
        local y = vec.y

        local alpha = math.floor(255 - 255 * (realtime - shot.start_time))

        if realtime - shot.start_time >= 1 then
            alpha = 0
        end

        if x ~= nil and y ~= nil then
            draw_shot(x , y, alpha, shot.damage, shot.result)
        end
        
        shot.frame_time = realtime

        if realtime - shot.start_time >= 1 then
            table.remove(shots, i)
        end
    end
end

local function morgenhit_shot(e)
    local time = globalvars.get_real_time()


    table.insert(shots, {
        position = { x = e.aim_point.x, y = e.aim_point.y, z = e.aim_point.z },
        damage = e.server_damage,
        start_time = time,
        frame_time = time
    })
end

client.register_callback('paint', morgenhit_render)
client.register_callback('shot_fired', morgenhit_shot)


local function on_paint()
    local self = entitylist.get_local_player()
    if not self or not self:is_alive() then
        return
    end

    local player = entitylist.get_local_player()
    local is_scoped = player:get_prop_bool(se.get_netvar("DT_CSPlayer", "m_bIsScoped"))
    local view_scope = viewmodel_on_scope:get_value()
    local r_drawvgui = se.get_convar("r_drawvgui")
    local fov_cs_debug = se.get_convar("fov_cs_debug")

    if enable_scope:get_value() and engine.is_connected() then
    if is_scoped then 
        local screensize = engine.get_screen_size()
        local start_x, start_y = screensize.x /2, screensize.y /2
        local offsett = line_offset:get_value()
        local lengthh = line_length:get_value()
        local width = 1

        renderer.rect_filled_fade(vec2_t.new(start_x - offsett + 1, start_y), vec2_t.new(start_x - offsett - lengthh + 1, start_y + width), line_color_first:get_value(), line_color_second:get_value(), line_color_second:get_value(), line_color_first:get_value())
        renderer.rect_filled_fade(vec2_t.new(start_x + offsett, start_y), vec2_t.new(start_x + offsett + lengthh, start_y + width), line_color_first:get_value(), line_color_second:get_value(), line_color_second:get_value(), line_color_first:get_value())
        
        renderer.rect_filled_fade(vec2_t.new(start_x, start_y + offsett), vec2_t.new(start_x + width, start_y + offsett + lengthh), line_color_first:get_value(), line_color_first:get_value(), line_color_second:get_value(), line_color_second:get_value())
        renderer.rect_filled_fade(vec2_t.new(start_x, start_y - offsett + 1), vec2_t.new(start_x + width, start_y - offsett - lengthh + 1), line_color_first:get_value(), line_color_first:get_value(), line_color_second:get_value(), line_color_second:get_value())
        r_drawvgui:set_float(0)
        else
        r_drawvgui:set_float(1)
    end
end
if view_scope and is_scoped then
    fov_cs_debug:set_float(90)
else
    fov_cs_debug:set_float(0)
end
end
    client.register_callback("paint", on_paint)


    local tpp = se.get_convar('cam_idealdist')
client.register_callback('create_move', function()
    if thirdperson_enable:get_value() then
    tpp:set_int(distation:get_value())
    else
    tpp:set_int(100)
    end
end)


local messages = {
    "соси тупое уебище",
    "иди купи helio.lua",
    "11",
    "ты че с никсваром, раз убить меня не можешь",
    "ты когда хсать меня будешь?",
    "отлитаешь",
    "упала нищенка",
    "бай helio.lua",
    "ты че с кряком пидорас?",
    "тебя когда скит бустить будет?",   
    "kill by fipp ",  
    "отлител от helio.lua",  
    "сходи купи кфг",
    "ты когда убивать будешь?", 
    "купи антиаимы",
    "ливни с сервера",
    "куда пикаеш?",
    "уебище хснутое",
    "где твои антиаимы?",  
    "i love fatality",
    "i love nixware",    

}
client.register_callback("player_death", function(event)
    
    local attacker_index = engine.get_player_for_user_id(event:get_int("attacker",0))
    local died_index = engine.get_player_for_user_id(event:get_int("userid",1))
    local me = engine.get_local_player()

    local random = math.random(1, #messages)

        if attacker_index == me and died_index ~= me and trashtalk_enabled:get_value() then
            
            engine.execute_client_cmd(string.format("say %s" , messages[random]))
        
        end
end)

local clan_nazad = ui.get_check_box("misc_clantag"):get_value()
local m_iTeamNum = se.get_netvar("DT_BasePlayer", "m_iTeamNum")
local a1 = 0
local a2 = 0
local a3 =
{
"",
"h",
"he",
"hel",
"heli",
"helio",
"helio",
"helio",
"helio",
"heli",
"hel",
"he",
"h",
"",
}

function paint()
    if clan:get_value() then
    if engine.is_in_game() then
        if a1 < globalvars.get_tick_count() then   
            a2 = a2 + 1
            if a2 > 14 then
                a2 = 0
            end
            se.set_clantag(a3[a2])
            a1 = globalvars.get_tick_count() + 18
        end
    end
    local clan = ui.get_check_box("misc_clantag"):set_value(false)
else
    ui.get_check_box("misc_clantag"):set_value(clan_nazad)
end
end
client.register_callback("paint", paint)


local font        = renderer.setup_font("C:/Windows/Fonts/verdana.ttf", 12, 128 + 16)
local notify =
    (function()
    local a = {callback_registered = false, maximum_count = 7, data = {}}
    function a:register_callback()
        if self.callback_registered then
            return
        end
        client.register_callback(
            "paint",
            function()
                local b = {engine.get_screen_size().x, engine.get_screen_size().y}
                local c = {56, 56, 57}
                local d = 5
                local e = self.data
                for f = #e, 1, -1 do
                    self.data[f].time = self.data[f].time - globalvars.get_frame_time()
                    local g, h = 150, 0
                    local i = e[f]
                    if i.time < 0 then
                        table.remove(self.data, f)
                    else
                        local j = i.def_time - i.time
                        local j = j > 1 and 1 or j
                        if i.time < 0.5 or j < 0.5 then
                            h = (j < 1 and j or i.time) / 0.5
                            g = h * 150
                            if h < 0.2 then
                                d = d + 15 * (1.0 - h / 0.2)
                            end
                        end
                        local k = {renderer.get_text_size(font, 12, i.draw).x, renderer.get_text_size(font, 12, i.draw).y}
                        local l = {b[1] / 2 - k[1] / 2 + 3, b[2] - b[2] / 50 * 13 + d}
                        renderer.text(i.draw, font, vec2_t.new(l[1], l[2] - 5), 12, color_t.new(0, 0, 0, 255))
                        renderer.text(i.draw, font, vec2_t.new(l[1], l[2] - 6), 12, color_t.new(255, 255, 255, 255))
                        d = d - 10
                    end
                end
                self.callback_registered = true
            end
        )
    end
    function a:paint(m, n)
        local o = tonumber(m) + 1
        for f = self.maximum_count, 2, -1 do
            self.data[f] = self.data[f - 1]
        end
        self.data[1] = {time = o, def_time = o, draw = n}
        self:register_callback()
    end
    return a
end)()


local function shot_fired(shot_info)
	reason = shot_info.result == 'unk' and 'unknown' or shot_info.result

	if log_enable:get_value() and (reason == 'desync' or reason == 'spread' or reason == 'occlusion' or reason == 'death') then
        return {notify:paint(2, 'Missed shot due to ' .. reason)} and print('Missed shot due to ' .. reason)
	end
end
client.register_callback('shot_fired', shot_fired)


local hitgroups =
{
    [0] = 'generic',
    [1] = 'head',
    [2] = 'chest',
    [3] = 'stomach',
    [4] = 'left arm',
    [5] = 'right arm',
    [6] = 'left leg',
    [7] = 'right leg',
    [8] = 'gear'
}

local function player_hurt(event)
    localplayer = engine.get_player_info(entitylist.get_local_player():get_index()).name
    userid = engine.get_player_info(engine.get_player_for_user_id(event:get_int('userid', 0))).name
    attacker = event:get_int('attacker', 0) ~= 0 and engine.get_player_info(engine.get_player_for_user_id(event:get_int('attacker', 0))).name or 'world'
    dmg_health = event:get_int('dmg_health', 0)
    hitgroup = hitgroups[event:get_int('hitgroup', 0)]

if log_enable:get_value() and attacker == localplayer and userid ~= localplayer then
    print("Hit " .. userid.. (hitgroup == 'generic' and '' or ' in the ' ..hitgroup).. ' for ' ..dmg_health.. ' dmg')
return {notify:paint(2, "Hit " .. userid.. (hitgroup == 'generic' and '' or ' in the ' ..hitgroup).. ' for ' ..dmg_health.. ' dmg')}
end
end
client.register_callback('player_hurt', player_hurt)


local is_round_started = false

client.register_callback("round_prestart", function(event) 
    is_round_started = true
    freezetime = true
end)

client.register_callback("round_start", function(event) 
    freezetime = false
    is_round_started = true
end)


local weapons_list = {"", "buy scar20; buy g3sg1", "buy awp", "buy ssg08", "buy ak47; buy m4a1; buy m4a1_silencer", "buy aug; buy sg556", "buy famas; buy galilar"}
local pistols_list = {"", "buy elite", "buy deagle", "buy tec9; buy fiveseven; buy cz75a", "buy p250"}
local other_list = {"buy vest; buy vesthelm;", "buy hegrenade;", "buy molotov; buy incgrenade;", "buy smokegrenade;", "buy taser;", "buy defuser;"}

client.register_callback("create_move", function() 
	if is_round_started then
		if buybot_enable:get_value() then
			local weapon = weapons_list[primary_weapon:get_value() + 1]
			local pistols = pistols_list[secondary_weapon:get_value() + 1]
			local other = ""

			for i = 1, 6 do
				other = other..((utilites:get_value(i - 1) and other_list[i]) or "")
			end

			engine.execute_client_cmd(weapon)
			engine.execute_client_cmd(pistols) 
			engine.execute_client_cmd(other) 
		end
		is_round_started = false
	end
end)


local function main()
    if autostraf:get_value() then
        if engine.is_connected() then
    
            local localPlayer = entitylist.get_local_player()
                
            m_vecVelocity = {
                [0] = se.get_netvar("DT_BasePlayer", "m_vecVelocity[0]"),
                [1] = se.get_netvar("DT_BasePlayer", "m_vecVelocity[1]")
            }
        
            velocity = math.sqrt(localPlayer:get_prop_float(m_vecVelocity[0]) ^ 2 + localPlayer:get_prop_float(m_vecVelocity[1]) ^ 2)
    
            if velocity ~= nil then
                if velocity > 5 then
                    ui.get_check_box("misc_autostrafer"):set_value(true)
                else
                    ui.get_check_box("misc_autostrafer"):set_value(false)
                end
            else
                ui.get_check_box("misc_autostrafer"):set_value(true)
            end
    
        else
    
            velocity = nil
    
        end
    end
    end
    
    local function on_unload()
    
        ui.get_check_box("misc_autostrafer"):set_value(true)
    
    end
    
    client.register_callback("paint", main)
    client.register_callback("unload", on_unload)
